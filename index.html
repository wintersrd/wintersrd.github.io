<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> Robert Danger Winters </title>

  
  <link rel="stylesheet" href="http://robertwinters.nl/css/poole.css">
  <link rel="stylesheet" href="http://robertwinters.nl/css/syntax.css">
  <link rel="stylesheet" href="http://robertwinters.nl/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="http://robertwinters.nl/index.xml" rel="alternate" type="application/rss+xml" title="Robert Danger Winters" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='https://fonts.googleapis.com/css?family=Raleway:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="brand"><a href="http://robertwinters.nl">Robert Danger Winters</a></h1>
      <p class="lead">
       Experienced BI Practitioner 
      </p>
    </div>



    <ul class="sidebar-nav">
      <li><a href="http://robertwinters.nl/blog">Posts</a></li>
      
        <li><a href="/about/">About </a></li>
      
      <a href="http://www.slideshare.net/RobWinters" target="_blank"> My Slideshare</a>
      <br/>
      <a href="https://www.dropbox.com/s/0t3o2xg04ccc81r/Robert%20Winters.pdf" target="_blank">My CV</a>
      <br/>
      
    </ul>
      
      <a href="https://nl.linkedin.com/in/wintersrd"><i class="fa fa-linkedin-square"></i></a>&nbsp;&nbsp;
      <a href="http://nl.linkedin.com/in/wintersrd"><i class="fa fa-facebook-square"></i></a>&nbsp;&nbsp;
      <a href="https://github.com/wintersrd"><i class="fa fa-github-square"></i></a>&nbsp;&nbsp;
      

    <p class="footnote">powered by <a href="http://hugo.spf13.com">Hugo</a> <br/>
    &copy; 2016 Rob Winters. All rights reserved.</p>
    
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2016/04/big-data-conference-naarden/">
        Architecting for Real-Time Big Data Analytics
      </a>
    </h1>

    <span class="post-date">Apr 5, 2016</span>

    


    <p>I was recently invited to speak in Naarden on experiences with architecting a big data platform. These are the slides that I used to facilitate the talk.</p>

<p><iframe src="//www.slideshare.net/slideshow/embed_code/key/LTnDLOmJIErDW" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/RobWinters1/architecting-for-realtime-big-data-analytics" title="Architecting for Real-Time Big Data Analytics" target="_blank">Architecting for Real-Time Big Data Analytics</a> </strong> from <strong><a target="_blank" href="//www.slideshare.net/RobWinters1">Rob Winters</a></strong> </div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/06/2015-06-27-questions-to-ask-for-self-service-bi/">
        The Role of Self-Service in your Business Intelligence Strategy
      </a>
    </h1>

    <span class="post-date">Jun 27, 2015</span>

    


    

<p>The BI industry is subject to a variety of debates currently, from <a href="http://www.informationweek.com/big-data/big-data-analytics/hadoop-5-undeniable-truths/a/d-id/1316832">whether or not Hadoop will replace the data warehouse</a> to <a href="http://www.rtinsights.com/iot-real-time-analytics-hype-cycle-vs-delivering-results/">internet of things and real time analytics</a>, but one of the topics that most directly impacts your business partners is much more simple: to what degree should a BI team build out a self-service infrastructure? According to some vendors, <a href="http://www.cbronline.com/news/big-data/platforms/sap-bi-2015-top-5-take-aways-4603283">self-service analytics are bullshit</a>; according to others, <a href="http://www.kdnuggets.com/2014/11/the-future-analytics-3-predictions-bi-2015.html">self-service is the future of BI</a>. Regardless of which camp you belong to, before moving down the path of self-service there are five questions you should ask yourself:</p>

<p><strong>1. What business benefit do I hope to achieve?</strong> Far and away, this is the most critical question to ask before moving forward. Self-service can afford an organization a variety of benefits: faster report development, better analytical capacity in other departments, more various views on the data to address related but different questions. Identifying and prioritizing the desired benefit(s) will be critical to moving towards a self-service organization.</p>

<p><strong>2. Is my data ready for self-service?</strong> Many BI teams have built up cumbersome data structures and flows over the years to meet report demands and complex business rules. However, a self-service data model will need to be much simpler if users will be working directly against what you make available; the average business user will have the knowledge or willingness to memorize that D_ORD_CHG_CD represents order status code while F_ORD_CHG_AMT represents the order amount. Scoping your data and how to structure it for layman consumption will be critical to get user buy in.</p>

<p><strong>3. Are my users ready for self service?</strong> Organizations often put out self-service tools as &ldquo;just another reporting solution&rdquo;, but the real benefit to self-service comes from changing how the organization interacts with your data. Properly assessing the training required to empower your organization&rsquo;s decision making should happen <em>before</em> rolling out new platforms.</p>

<p><strong>4. Is my BI team ready for new questions?</strong> Just as the delivery mechanism and user interactions change, the questions posed to your analysts and developers will differ. Your BI team will need to be ready to partner with the business in discovering <em>how</em> and <em>why</em> via exploration and collaboration, not just delivering the numbers.</p>

<p><strong>5. How will I handle governance, quality control, and data security?</strong> By exposing business users to underlying data and allowing them the freedom to create on their own, the risk increases exponentially that someone will see something they shouldn&rsquo;t or a view will be created which is misleading and/or inaccurate. While this is nothing new (folks have been lying with Excel for years), it creates a new challenge because it is &ldquo;in the reporting system&rdquo;. Have a strategy to manage/identify &ldquo;official&rdquo; sources and reports, protect users from sharing confidential information, and ensure the quality of publicly available reporting within your environment.</p>

<h3 id="additional-resources:179c7176899eeb46f9cef02bee18b126">Additional resources:</h3>

<ul>
<li><p><strong>Tableau:</strong> <a href="http://www.tableau.com/learn/whitepapers/deploying-flexible-self-service-analytics">Deploying Flexible, Self-Service Analytics</a></p></li>

<li><p><strong>Qlik:</strong> <a href="http://www.qlik.com/en/explore/products/empowers-it">Welcome to the Era of Governed Discovery</a></p></li>

<li><p><strong>TDWI:</strong> <a href="https://www.microstrategy.com/Strategy/media/downloads/white-papers/TDWI_Self-Service-BI.pdf">Checklist: Self-Service BI</a></p></li>
</ul>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/06/2015-06-23-insights-conference/">
        Insights Conference 2015, Neuromarketing in eCommerce
      </a>
    </h1>

    <span class="post-date">Jun 23, 2015</span>

    


    <p>This week I had the privilege to sit in on a conference discussing <a href="https://en.wikipedia.org/wiki/Neuromarketing">neuromarketing</a>: the roles of cognitive psychology, intrinsic motivation/intent, and emotional response analysis in designing products and experiences.
It&rsquo;s an interesting contrast from the usual approaches like A/B testing because rather than simply evaluating the success metrics, it attempts to explain <em>why</em> consumers react the way they do to changes in experience, measured by EEGs and eye tracking. Presenters included Transavia, ING, Blue Mango, Telfort, and Incentro. Some key takeaways:</p>

<p><strong>1. Assumptions of customer preference should always be tested:</strong> Blue Mango shared the results of a test based on the idea that customers would be more preferential towards a brand they already owned; for example, Samsung customers would respond stronger to a Samsung ad than an LG one. In only case (Apple) did they find this to be the case.</p>

<p><strong>2. Effective personalization should be based on intrinsic needs:</strong> Incentro broke down personalization into three theories of why individuals are influenced:</p>

<ul>
<li><p><em>Persuasive:</em> The information presented is convincing that this the right choice</p></li>

<li><p><em>Motivation level:</em> The effort required to take the action is low relative to my intrinsic motivation (why not?)</p></li>

<li><p><em>Proximity:</em> The offer is presentated at a time/place where it aligns to a consumer&rsquo;s intrinsic needs</p></li>
</ul>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/06/2015-06-22-lod-calcs-in-tableau/">
        The Power of Level of Detail Calculations in Tableau
      </a>
    </h1>

    <span class="post-date">Jun 22, 2015</span>

    


    

<p>Just a quick one, we&rsquo;ve been playing a lot with level of detail calculations lately in Tableau 9 and I have to say, they&rsquo;re <em>incredible</em>, especially when combined with context filtering. A few useful ones so far:</p>

<h3 id="customer-lifetime-value:e4fd28e5a76e95e9da93c0c0b0a15752">Customer Lifetime Value</h3>

<p>Presuming you have a transactions table:</p>

<pre><code>First transaction: {FIXED [customer_id] : min([transaction_date])}
Tenure month: DATEDIFF('month',[First transaction], [transaction_date])
</code></pre>

<h3 id="rfm-recency-frequency-lifetime-value-modeling:e4fd28e5a76e95e9da93c0c0b0a15752">RFM (Recency, Frequency, Lifetime Value) Modeling</h3>

<pre><code>Recency: DATEDIFF('month',{FIXED [customer_id] : max([transaction_date])})
Frequency: {FIXED [customer_id] : countd([order_id])}
Lifetime Value: {FIXED [customer_id] : sum([order_value])}
</code></pre>

<h3 id="salesperson-effectiveness-index-vs-team-average:e4fd28e5a76e95e9da93c0c0b0a15752">Salesperson effectiveness (% index vs team average)</h3>

<pre><code>Size of Team: {FIXED [team_id] : countd([account_mgr_name])}
Team Revenues: {FIXED [team_id] : sum([order_value])}
Salesperson Index: sum([order_value])/avg([Team Revenues]/[Size of Team])
</code></pre>

<p>Those are a few examples, but these are really a game-changer with Tableau; now we can skip entire subqueries and ETL processes, massively accelerating analytics and dashboard development.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/06/2015-06-14-experiences-redshift-vertica/">
        Redshift vs Vertica, an analyst&#39;s experience
      </a>
    </h1>

    <span class="post-date">Jun 14, 2015</span>

    


    

<p>When it comes to conducting analysis on very large structured data sets, there are a limited number of viable players which won&rsquo;t require a second mortgage and army of consultants to use (looking at you, Exadata). For the last several years my platform of choice has been HP Vertica: it&rsquo;s fast, scales well, relatively easy to manage/performance tune, and is fairly middle of the pack for pricing. However, for the last several months I&rsquo;ve been using Redshift as my primary data warehouse and feel ready to make a comparison on where the platforms materially differ.</p>

<h3 id="data-loading-structured-flat-files:8290a9e3b177c64d60b0e5b27f06bd31">Data Loading: Structured flat files</h3>

<ul>
<li><p><strong>Vertica</strong>: Vertica&rsquo;s standard loading paradigm is to load the file via a local copy command and loads into memory. This creates a potentially volatile loading pattern (dependent on network performance) but is extremely fast a parallelizes well if the machine executing the copy statement is in the same network. When running loading jobs like &ldquo;copy all tables from a production DB&rdquo; or &ldquo;I need ad hoc data in the DB for analysis&rdquo;, Vertica was significantly faster/easier than Redshift.</p></li>

<li><p><strong>Redshift</strong>: Refshift can load from S3, EMR, or DynamoDB (it can also load from another machine via SSH, but the mechanism to do so is enormously cumbersome). Since it is lacking in any COPY FROM LOCAL functionality, loading data from a local source is both more cumbersome and much slower. However, loading data from Hadoop (presuming it&rsquo;s an EMR cluster) is much better in Redshift.</p></li>
</ul>

<h3 id="time-and-time-series:8290a9e3b177c64d60b0e5b27f06bd31">Time and Time Series</h3>

<ul>
<li><p><strong>Redshift</strong>: Time series analysis is where Redshift falls flat; the database is lacking certain basic functions like _TO<em>TIMESTAMP</em>&hellip; god help you if you need to work with Unix epochs. Most basic date functions are represented (ex. <em>DATEDIFF</em>, <em>DATETRUNC</em>) but there are very few analytical or window functions available.</p></li>

<li><p><strong>Vertica</strong>: In contrast, Vertica has an enormous number of date functions available to assist in analysis of event stream data (although not all functions are implemented in ISO/ANSI standards). Additionally, it&rsquo;s possible to do advanced time analytics in raw SQL. For example, sessionization of an event stream can be done using conditional true events.</p></li>
</ul>

<h3 id="json-handling:8290a9e3b177c64d60b0e5b27f06bd31">JSON Handling</h3>

<ul>
<li><p><strong>Redshift</strong>: Redshift allows direct loading of JSON objects to tables and will map each key to the appropriate column during loading. This solution works well when the arrays are consistently defined as it will offer high performance on read but is a liability if new keys are constantly being added to your arrays - those new records will be ignored until the column is added to the table. Redshift also has excellent support for querying JSON objects stored in strings.</p></li>

<li><p><strong>Vertica</strong>: In contrast, Vertica stores the JSON object as written in a Flex Table, preserving the whole record and using a view to allow access via SQL to the array. The DBA can choose which (if any) columns should be materialized as database columns; this approach is more complicated from an end-user perspective but ensures that data is never lost. Vertica also does not support querying JSON strings directly except by abusing functions developed for use on Flex tables.</p></li>
</ul>

<h3 id="physical-structure-management:8290a9e3b177c64d60b0e5b27f06bd31">Physical Structure Management</h3>

<ul>
<li><p><strong>Vertica</strong>: The reason that column stores are so performant is the physical sorting and partitioning of the data by column; like indices, tuning for performance is a long term process and may require many iterations. Vertica allows multiple sort and compression designs for each table, allowing one to optimize for a variety of queries at the cost of load performance. Additionally, changes can be executed on the fly without impacting end users or dropping tables.</p></li>

<li><p><strong>Redshift</strong>: Redshift allows the same level of sorting/node distribution logic, but each table can only have one physical manifestation. Additionally, changes to the physical structure require the table to be dropped and recreated. This significantly slows down the DBA&rsquo;s work on performance tuning.</p></li>
</ul>

<h3 id="conclusion:8290a9e3b177c64d60b0e5b27f06bd31">Conclusion</h3>

<p>So, which one is &ldquo;better&rdquo;? Objectively, neither - both platforms bring strengths and weaknesses to the table. I would argue that Vertica has a more mature functionality set and is easier/more flexible to work in, with the downsides of higher cost and more administrative work required.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/06/2015-06-02-personal-tableau-push-reporting/">
        Providing personal push reporting via Tableau
      </a>
    </h1>

    <span class="post-date">Jun 2, 2015</span>

    


    

<p>Tableau is one of my favorite Business Intelligence platforms: it achieves an excellent balance of flexibility and control and allows users to explore the data and create new insights. However, the pricing can be prohibitively expensive for small companies ($1k per user up front, $200 per year afterwards) and not all members of the organization require the full interactor experience: some people just want to see what happened yesterday, last week, or last month. As a result, many companies start with just a limited use PoC and miss a great opportunity to get the organization used to looking at the numbers. At TravelBird we&rsquo;ve built a Python script to allow everyone in the company (even those without Tableau licenses) to receive a personalized report every day.</p>

<h3 id="the-key-tabcmd-and-url-filters:4be10db2518cc0389946805eeffeded2">The key: tabcmd and URL filters</h3>

<p>One of the most powerful Tableau tools available to a BI Manager who wants to share data is tabcmd, which allows incredible functionality to generate images, export PDFs and data, and manage a number of other tasks on the server. For example, if we imagine our server is <em><a href="https://reporting.MyCompany.com">https://reporting.MyCompany.com</a></em>, the workbook is <em>Daily Sales Report</em>, and the default view is <em>Yesterday Sales Summary</em>, then to generate a PNG summary, PDF report, and the underlying data we could execute:</p>

<pre><code>tabcmd login -s https://reporting.MyCompany.com -u &lt;admin_username&gt; -p &lt;admin_password&gt;
tabcmd export &quot;Daily Sales Report/Yesterday Sales Summary&quot; --pdf -f &quot;C:\output\Sales.pdf&quot;
tabcmd get &quot;Daily Sales Report/Yesterday Sales Summary&quot; --png -f &quot;C:\output\summary.png&quot;
tabcmd export &quot;Daily Sales Report/Yesterday Sales Summary&quot; --csv -f &quot;C:\output'sales.csv&quot;
tabcmd logout
</code></pre>

<p>As imaginable, this could all be compiled into an email using a tool like <a href="http://www.blat.net/">Blat</a> and distributed to a group. However, the trick to personal emails are Tableau&rsquo;s URL filters, which can be used both on the web and with tabcmd. For example, using <em><a href="https://reporting.mycompany.com/#/DailySalesReport/YesterdaySalesSummary">https://reporting.mycompany.com/#/DailySalesReport/YesterdaySalesSummary</a></em> will show the organization&rsquo;s total performance, but adding <strong>?SalesPerson=Joe Smith</strong> to the end will filter the data to only Joe. The real power to this trick is that <strong>the filter does not need to be visible on the dashboard, only present in the workbook filters</strong>. Provided the reports are built with the desired filter in the data set, almost any report can be automatically personalized on distribution.</p>

<h3 id="distributing-personal-reports:4be10db2518cc0389946805eeffeded2">Distributing personal reports</h3>

<p>To make this work, three things are required: the base report to distribute, a table containing the filter clause and recipient email, and an email provider who plays well with Python (we use <a href="https://sendgrid.com/">SendGrid</a> as they have a convenient library). In our job we&rsquo;ve added additional controls to provide multiple scheduling options, choose on a recipient basis what attachments are included, and track the last successful distribution, but the base job is relatively straightforward (presume the reference table contains salesperson, region, and email):</p>

<pre><code class="language-python">import sendgrid
import pyodbc
import os
import datetime

sendgrid_user = 'my_user'
sendgrid_pass = 'my_pass'

tmp_folder = 'C:\\temp\\'
tableau_folder = 'C:\\Program Files\\Tableau\\Tableau Server\
    \\9.0\\bin\\tabcmd.exe'
tab_user = 'my_admin'
tab_pass = 'my_admin_pass'


def return_recipients():
    odbc_cxn = pyodbc.connect('DSN=my_db')
    cxn = odbc_cxn.cursor()
    cxn.execute(&quot;select salesperson_name, region, salesperson_email from ref_table&quot;)
    results = cxn.fetchall()
    cxn.close()
    odbc_cxn.close()


def generate_files(baseReport, fileName, filteredName):
    attachments = []
    os.command(tableau_folder +
        ' login -s https://reporting.travelbird.com -u %s -p %s') % \
        (tab_user, tab_pass)
    os.command(tableau_folder + ' export %s --png -f &quot;%s%s.png&quot;') % \
        (filteredName, tmp_folder, fileName)
    attachments.append('%s.png' % fileName)
        os.command(tableau_folder + ' export %s --pdf -f &quot;%s%s.pdf&quot;') % \
            (filteredName, tmp_folder, fileName)
        attachments.append('%s.pdf' % fileName)
        os.command(tableau_folder + ' export %s --csv -f &quot;%s%s.csv&quot;') % \
            (filteredName, tmp_folder, fileName)
        attachments.append('%s.csv' % fileName)
    os.command(tableau_folder + ' logout')
    return attachments


def send_email(user, toAddress, subject, attachments):
    sg = sendgrid.SendGridClient(sendgrid_user, sendgrid_pass)
    message = sendgrid.Mail()
    message.set_from(from_email)
    message.set_subject(subject)
    body = 'Good morning %s,\n' % user
    body += 'Attached is the %s report for %s.\n\n' % \
        (subject, time.strftime('%a, %d %b %Y'))
    body += 'For questions, please contact bi@MyCompany.com'
    message.set_text(body)
    message.add_to(toAddress)
    for attachment in attachments:
        message.add_attachment(attachment, tmp_folder + attachment)
    sg.send(message)


def main():
    baseReport = 'Daily Sales Report/Yesterday Sales Summary'
    fileName = baseReport.split('/')[0]
    email_list = return_recipients()
    for recipient in email_list:
        filteredName = baseReport + &quot;?Region=&quot; + recipient.region
        attachments = generate_files(baseReport, fileName, filteredName)
        send_email(recipient.salesperson_name, recipient.salesperson_email, fileName, attachments)
        for file in attachments:
            os.remove(file)


if __name__ == '__main__':
    main()
</code></pre>

<p>And that&rsquo;s it! With this small piece of code, every member in the organization can start the day with their personalized report and have the full data if they need to do further analysis. As opposed to the Tableau email platform, this script based approach can offer a huge amount of flexibility:
* Central BI management of distributions and distributed content
* Database checks can be added for given reports (ex. check that sales data is complete at 7 AM before sending out the PDF)
* Multiple reports or PNGs could be consolidated into one email
* The entire message body can be tuned/customized to meet business needs. For example, populating the summary statistics into the subject for better experience</p>

<p>What might it look like? With the Superstore sample data:</p>

<p><img src="{{site.url}}/assets/personal_report_example.png" alt="personalized report" /></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/04/2015-04-10-data-vault-source-automation/">
        Data Vault Loading Automation
      </a>
    </h1>

    <span class="post-date">Apr 10, 2015</span>

    


    

<p>Note: These posts on data vault automation are an in-depth discussion of functionality described <a href="http://www.slideshare.net/RobWinters1/data-vault-automation-at-the-bijenkorf">in a 10 Mar 2015 presentation on the Bijenkorf&rsquo;s DWH architecture</a></p>

<p>When we began our vault rollout, one of the initial challenges we faced was the disparity of relational systems to work with: MySQL (various versions), Oracle 11g, Vertica, etc. While heterogeneous replication is an ideal solution in this landscape, the majority of servers were partner hosted and so actual code/feature deployment on the machines was not possible. As such, the easiest solution available was to deploy code generators based on metadata derived from our staging environments. This approach offers a number of advantages:</p>

<ul>
<li><p><strong>Easy integration of new tables:</strong> Rather than building new ETLs or modifying code to add new tables from existing sources, we can integrate the new information automatically by deploying the DDL in the DWH</p></li>

<li><p><strong>Resiliency against source changes:</strong> In the event that the source system adds additional columns to the source, changes referential integrity, etc, ETLs are not impacted. Only INT-&gt;VARCHAR changes is source data models cause issues.</p></li>

<li><p><strong>Automatic full vs incremental loading:</strong> Using the last timestamp off our ODS view layer allows the scripts to only pull the new records from the sources; in the event that nothing is currently in the ODS, the engine will automatically pull everything.</p></li>
</ul>

<h3 id="engine-workflow:133b05d48047fcbc0514da03bd26193c">Engine workflow</h3>

<p><img src="{{site.URL}}/static/DV_Automation.png" alt="High level data vault workflow model" /></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/03/2015-03-29-building-simple-recommenders/">
        Real-time recommenders, part four -  Creating a recommender
      </a>
    </h1>

    <span class="post-date">Mar 29, 2015</span>

    


    

<h3 id="introduction:9ec7d062fbf00e14307a23bc18b30821">Introduction</h3>

<p>Now that we have both an offline and real-time event stream available, we need to calculate a recommender model to determine what to serve users. Fundamentally, most item-based recommenders work to answer the same question: &ldquo;given product 1, what products (2-N) should I show a customer (and how good of a recommendation are they)&rdquo;? There are a number of complex modeling techniques available and off-the-shelf functions in tools like <a href="http://mahout.apache.org/">Mahout</a> and <a href="http://prediction.io/">Prediction.IO</a>, one of the best ways to familiarize oneself with how these models work is to calculate it yourself. To that end, an easy starting point is a <a href="http://en.wikipedia.org/wiki/Slope_One">slope one mode</a>, a non-trivial way to calculate item and user similarities.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/03/2015-03-22-event-processing/">
        Real-time recommenders, part three -  Event tracking (processing events)
      </a>
    </h1>

    <span class="post-date">Mar 22, 2015</span>

    


    

<h3 id="introduction:67586a2fe6487ff004d9849a06b13c4b">Introduction</h3>

<p>In order to utilize our event data from Kinesis we have configured two separate feeds: one non-real-time for reporting and archiving purposes and one real time feed for use cases like recommendations and last viewed items. While snowplow has use case specific libraries for both, we built our own utilities for the following reasons:</p>

<ul>
<li><p><strong>Flexibility:</strong> Building our own library allows easier loading to multiple database engines and/or unique archive flows</p></li>

<li><p><strong>Speed:</strong> Using a basic loader allows event rotation into the database once a minute without any loss of information.</p></li>

<li><p><strong>Archive Structure:</strong> The default snowplow libraries do not make any provision for DB loading and archiving to S3; for reliability purposes we wanted both</p></li>
</ul>

<h3 id="database-loading:67586a2fe6487ff004d9849a06b13c4b">Database loading</h3>

<p>In order to process the data for loading into the database we are using a mixture of the default <a href="https://github.com/snowplow/snowplow/tree/master/3-enrich/scala-kinesis-enrich">Kinesis Enricher</a>, sed, a small Python script for event validation, and cronolog to write to a file. The exact flow looks something like:</p>

<ol>
<li><p>Kinesis enricher stderr and stdout to stdout <code>/var/lib/snowplow_enrich/snowplow-kinesis-enrich-0.2.0 --config /var/lib/snowplow_enrich/snowplow.conf 2&gt;&amp;1</code></p></li>

<li><p>sed to remove checkpointing data from the event stream <code>sed -e '/^\[/d' | sed -e 's/\[pool.*$//'</code></p></li>

<li><p>A Python script which validates whether or not the event has been processed before and validates the custom JSON objects inside the structured event labels</p></li>

<li><p>Cronolog which rotates log files every minute <code>cronolog /data/logs/snowplow%Y%m%d%H%M.dat</code></p></li>
</ol>

<p>One issue with using cronolog is that it splits exactly on the minute, resulting in one event per minute being cut in half every minute. Concatenation of the logs before loading (for example, every 15 minutes) reduces the impact to one event per load, but this is still unacceptable - we would like 100% of events being written to the database. To correct, our loader uses a mixture of <strong>head</strong> and <strong>tail</strong> to grab the end of the last event for loading from the head of the log file currently being written. Once the log files are correctly merged, loading and backups become trivial:</p>

<pre><code>#!/bin/bash

RIGHTNOW=`date +%Y%m%d%H%M`
MINUTEAGO=`date -d '-1 minute' +%Y%m%d%H%M`
YEAR=`date +%Y`
MONTH=`date +%m`
DAY=`date +%d`

find /data/logs -cmin +1 -type f -exec mv &quot;{}&quot; /data/logs/loading/ \;
ls /data/logs/loading/snowplow*.dat | sort | xargs cat&gt; /data/logs/loading/temp.dat
head -n 1 /data/logs/snowplow$MINUTEAGO.dat&gt;&gt;/data/logs/loading/temp.dat
tail -n +2 /data/logs/loading/temp.dat &gt; /data/logs/loading/snowplow_merged_$RIGHTNOW.dat
rm /data/logs/loading/snowplow2*.dat
rm /data/logs/loading/temp.dat

/opt/vertica/bin/vsql -h my.loadbalancer.path -U $1 -w $2 -c &quot;copy stg.snowplow_events from local '/data/logs/loading/snowplow_merged_$RIGHTNOW.dat' with delimiter E'\t'  rejected data '/data/logs/loading/snowplow_rejected_$RIGHTNOW.dat'&quot;

gzip /data/logs/loading/snowplow_merged_$RIGHTNOW.dat

s3cmd put /data/logs/loading/snowplow_merged_$RIGHTNOW.dat.gz s3://bykdwh/snowplow/$YEAR/$MONTH/$DAY/
rm /data/logs/loading/snowplow_merged_$RIGHTNOW.dat.gz
</code></pre>

<p>Far simpler than the default loaders and extremely performant in our environment. Another advantage to having the log files on a minute (or five minute) basis is that it makes it extremely easy to restore an hour or a day if we need to reload.</p>

<h3 id="real-time-processing:67586a2fe6487ff004d9849a06b13c4b">Real time processing</h3>

<p>While the process outlined above is fantastic for reporting purposes, a one minute delay on the events is still not fast enough for a &ldquo;real time&rdquo; experience for users. Our objective for users is that the data is analyzed and recommendations updated before their next pageview; this gives us five seconds or less to process the event. To achieve this throughput we are using inline processing in a Python script to read specific data from the event, check records against redis, and execute a number of puts  to redis. While this approach is somewhat cumbersome and lower performance than using a language like Scala, it is still possible to achieve throughput of a few thousand events per second per thread - more than sufficient for most businesses.</p>

<p>The functional workflow of real-time processing looks something like:</p>

<pre><code class="language-python">import sys
import redis
import json
import fileinput

action_value={
    'action1':weight,
    'action2':weight,
    'action3':weight
}


def unlist(input_list):
    return '\t'.join(map(str,input_list))


def process_event(event):
    # Do some event processing to extract the correct user, event type (based on data in the event label), and SKU
    return (user_id, event_type, product_sku)


def main():
    counter = 0
    pipe = rec_set.pipeline()

    for line in sys.stdin:
        try:
            split_tab = []
            split_tab.append(line.split('\t'))
            split_tab = [val for sublist in split_tab for val in sublist]
            user_id, event_type, product_sku = process_event(split_tab)

            if product_sku is not None:
                # Do some lookups for recommendations and brand information, then load those recommendations to redis
            else:
                next
        except:
            next


if __name__ == '__main__':
    main()
</code></pre>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/03/2015-03-14-snowplow-event-capture/">
        Real-time recommenders, part two -  Event tracking (front end, collector, and bus)
      </a>
    </h1>

    <span class="post-date">Mar 14, 2015</span>

    


    

<h3 id="introduction:e09c72d4c3eec9feb46220c6919223cc">Introduction</h3>

<p>In order to generate recommendations for users, the first task is to generate user data. One of the best options available right now is to use <a href="https://github.com/snowplow/snowplow">Snowplow</a>, an open source event tracker built around the AWS stack. Using Snoplow plus <a href="http://www.google.com/tagmanager/">Google Tag Manager</a>, one can get event tracking running in just a few hours.</p>

<h3 id="front-end-tracker:e09c72d4c3eec9feb46220c6919223cc">Front End Tracker</h3>

<p>Rather rewriting already excellent documentation, simply follow the notes <a href="https://github.com/snowplow/snowplow/wiki/Integrating-javascript-tags-with-Google-Tag-Manager">here</a>. However, a few tips in getting started:</p>

<ol>
<li><p><strong>Start small:</strong> Capture Pageviews only and validate against Google Analytics. This will expose potential tracking issues in your front end immediately which might cause tracking issues (we initially were missing almost half of our events due to ajax refreshes).</p></li>

<li><p><strong>Be prepared for lots of data:</strong> Without having a baseline, it&rsquo;s easy to underestimate how much data will arrive. When we turned on page pings on a very conservative interval (every two minutes), <strong>event volume  doubled</strong> even though average time on page was well under a minute.</p></li>

<li><p><strong>Use the existing event types:</strong> Snowplow is prebuilt to support a number of different events, if at all possible use those rather than &ldquo;rolling your own&rdquo; to capture similar data.</p></li>
</ol>

<h3 id="event-capture-and-bus:e09c72d4c3eec9feb46220c6919223cc">Event Capture and Bus</h3>

<p>In order to get real time recommendations, data must be processed in real time; this rules out the &ldquo;production ready&rdquo; clojure collector and forces one to use the scala streaming collector. The good news is that this appears to be extremely stable; we have been using it in production for several months with no significant issues.</p>

<p>Configuration of the collector is <a href="https://github.com/snowplow/snowplow/wiki/Setting-up-the-Scala-stream-Collector">relatively straightforward</a>. Since our event volume can swing significantly during the day, we set up an AWS image which auto-starts the collector and configured an Elastic Beanstalk application for this purpose. The threshold used is CPU &gt;65% for launching an instance and &lt;25% for removing an instance as this was the greatest cause of event processing delays and dropped data. One major advantage of the streaming collector is that machines can be turned on and off with virtually no loss of data; using the clojure collectors, one can auto-scale up but must manually scale down to ensure that web logs rotate correctly.</p>

<p>While it is possible to write the event stream directly to stdout (for easy processing), we write the records to Kinesis as we have two consumer streams on the data set: one for real time recommendations and one for recording the data to the DB and archiving data to S3. One issue with Kinesis is that it does <em>not</em> autoscale. A quick estimate of event volume to bus utilization is that one needs one shard for every 10k events per minute, depending on how much additional data is written per event.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/03/2015-03-08-automatic-tableau-backups-to-s3/">
        Automating Tableau Backups via AWS
      </a>
    </h1>

    <span class="post-date">Mar 8, 2015</span>

    


    

<h3 id="introduction:6a2ccbe037512dd4d211ba76c4c998d1">Introduction</h3>

<p>Tableau is far and away my favorite Business Intelligence tool for its ease of development and performance on small (&lt;20M row) extracts, but I have always found the backup approach disappointing. Each backup can account for a substantial amount of disk space, there is no default backup rotation, and Windows offers insufficient tooling to effectively handle these tasks. Enter <a href="https://boto.readthedocs.org/en/latest/">boto</a>, the Python library for AWS. Using boto plus S3 and tabadmin, we were able to build a backup solution for Tableau which is:</p>

<ul>
<li><p>Infinitely space scalable</p></li>

<li><p>Fully automated and can email on failure</p></li>

<li><p>Handles daily/weekly/monthly backup rotation automatically. Currently we keep daily for two weeks, weekly for six months, and monthly for an indefinite period.</p></li>

<li><p>Low cost. As of February 2015 the storage cost of S3 is approximately $0.03 per month, so keeping backups only runs a few tens of dollars per year.</p></li>
</ul>

<h3 id="components:6a2ccbe037512dd4d211ba76c4c998d1">Components</h3>

<p>There are several critical functions to generating and rotating the backups effectively:</p>

<p><strong>1. Options manager:</strong> To read configuration details like AWS keys, bucket names, file naming conventions, etc</p>

<p><strong>2. Backup extractor:</strong> To pull the backup, in this case just a system call to tabadmin</p>

<p><strong>3. Uploader:</strong> Used to place the file in S3 and validate its placement. Given the file sizes, this must be a multipart upload</p>

<p><strong>4. Backup Rotator:</strong> Used to eliminate backups which no longer fit our retention policies</p>

<h3 id="options-management:6a2ccbe037512dd4d211ba76c4c998d1">Options Management</h3>

<p>Options were handled using the argparse and option parser libraries to store configuration details on our Tableau server; our configuration options were:</p>

<pre><code>[aws]
key: 
secret: 
bucket: 
days_to_keep_daily: 14
days_to_keep_weekly: 180


[Tableau] 
tempdir: C:/BACKUPS/
tabadmin_path: C:/Program Files/Tableau/Tableau Server/8.3/bin/tabadmin.exe
filename_base: TABLEAU_BACKUP
</code></pre>

<p>This affords the flexibility to easily change rotation schedule in the future.</p>

<h3 id="backup-extraction:6a2ccbe037512dd4d211ba76c4c998d1">Backup Extraction</h3>

<p>Handled using a simple system call to the tabadmin command based on the parameters set in the config file:</p>

<pre><code class="language-python">def generate_extract(configs):
	call(configs.get('Tableau','tabadmin_path') + &quot; backup -d &quot; + configs.get('Tableau','tempdir') + configs.get('Tableau','filename_base'))
</code></pre>

<h3 id="uploading-and-validating:6a2ccbe037512dd4d211ba76c4c998d1">Uploading and validating</h3>

<p>To upload the backup and validate the object, we built a number of small functions to upload the file and confirm its placement. Our files are laoded in a naming convention S3://{bucket}/{tableau_path}/{year}/{month}/{filename_root}-YYYY-MM-DD.tsbak which makes it easy to recover the appropriate backup. Specific functions used include:</p>

<ol>
<li><p>A multipart file uploader which is &ldquo;borrowed&rdquo; wholesale from <a href="http://boto.readthedocs.org/en/latest/s3_tut.html#storing-large-data">boto&rsquo;s S3 examples</a></p></li>

<li><p>A small function to validate the upload was successful using bucket.list()</p></li>
</ol>

<h3 id="file-rotation:6a2ccbe037512dd4d211ba76c4c998d1">File rotation</h3>

<p>Since we are backing up daily but have a tiered backup strategy, the most trivial way to do so is to generate a list of valid file names and remove any which do not conform to the list. Specifically, we will need:</p>

<ol>
<li><p>All file names which fit in the daily retention window (14 days ago through today)</p></li>

<li><p>All file names which match a Sunday (chosen snapshot day) and are between six months ago and today</p></li>

<li><p>All file names which have &ldquo;01&rdquo; as the date, regardless of year/month</p></li>
</ol>

<p>As a day can fit 0-3 of these conditions, the easiest solution was to generate three distinct lists, merge them, and deduplicate them using the set function. We can then pull a list of all keys from S3 for our Tableau backups, filtering them, and then deleting the undesired files. One caveat associated with S3 keys from boto: the file name is treated is the entire path after the bucket, so it is necessary to parse out the relevant information for finding the correct file. To do so, the function below is used:</p>

<pre><code class="language-python">def remove_old(connection, configs):
	keys = connection.list('tableau_backups')
	valid_keys = keys_to_keep(connection, configs)
	keylist = []
	for key in keys:
		keyname = key.key.rsplit('/',1)[1]
		if keyname not in valid_keys:
			keylist.append(key.key)
	for j in keylist:
		connection.delete_key(j)
</code></pre>

<h3 id="conclusion:6a2ccbe037512dd4d211ba76c4c998d1">Conclusion</h3>

<p>In addition to the functionality outlined above, it&rsquo;s also helpful to add in email notification in the event of failure and some additional logging. That said, this utility massively reduces data loss risks with Tableau and introduces a useful, low cost mechanism to maintain any easily restorable history of the server.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/03/2015-03-01-recommender-technology/">
        Real-time recommenders, part one - Overview of Technology
      </a>
    </h1>

    <span class="post-date">Mar 1, 2015</span>

    


    

<h3 id="introduction:57cb33d81dd0d3056e8bd85c8e797b99">Introduction</h3>

<p>This is the first in a series of posts on how to implement near-real-time tracking and personalization for your users based on off the shelf and open source technologies. While many organizations perceive &ldquo;real time&rdquo; as challenging, the solution outlined here has been tested to scale easily to ten million pageviews per day; significantly higher volumes than most organizations encounter.</p>

<h3 id="fundamental-components:57cb33d81dd0d3056e8bd85c8e797b99">Fundamental components</h3>

<p>In order to create recommendation for your users, a few fundamental components must be present in your technical environment:</p>

<ul>
<li><p><strong>Event Tracker:</strong> A mechanism to capture user activity in near real time and make it available for scoring/analysis.</p></li>

<li><p><strong>Data Platform:</strong> The environment where your models will be calculated and history stored. Typically column store databases or Hadoop are used.</p></li>

<li><p><strong>Data Presentation Platform:</strong> Where the user recommendations will be stored and presented from. High throughput of reads/writes is critical here.</p></li>

<li><p><strong>Front End Implementation:</strong> How your users will consume the recommendations from your models.</p></li>
</ul>

<p>That&rsquo;s it, regardless of whether you are personalizing for ten users or ten million. From start to finish, an entire recommender architecture can be developed and deplyoed in about a week. In the
next post I&rsquo;ll discuss implementation of Snowplow, an open source event tracking stack.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://robertwinters.nl/2015/01/2015-01-22-test-post/">
        Welcome
      </a>
    </h1>

    <span class="post-date">Jan 22, 2015</span>

    


    <p>I recently decided to start blogging on all things BI including dashboarding, technology, data science, etc.</p>

  </div>
  
  
  
  
</div>


  </body>
</html>
