+++
title = "What I love about Go"
date = 2013-01-25T08:49:00Z
updated = 2013-01-25T09:05:56Z
tags = ["programming", "golang"]
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

<h2><span style="font-weight: normal;">The best things about Go have nothing to do with the language.</span></h2><h3>Single Executable Output</h3>Go compiles into a single executable that runs natively on the target OS. No more needing to install java, .net, mono, python, ruby, whatever. Here's your executable, feel free to run it like a normal person. &nbsp;And you can target builds for any major OS (windows, linux, OSX, BSD).<br /><br /><h3>One True Coding Style</h3>GoFmt is a build tool that formats your source code in the standard Go format. No more arguing about spacing or brace matching or whatever. There is one true format, and now we can all move on... and even better, many editors integrate GoFmt so that your code can be automatically formatted whenever you save.<br /><br /><h3>Integrated Testing</h3>Testing is integrated into the language. Name a file with the suffix _test.go and it'll only build under test. You run tests simply by running "go test" in the directory. You can also define runnable example code with output that is checked at test time. &nbsp;This example code is then included in the documentation (see below)... now you'll never have examples in documentation with errors in them. &nbsp;Finally, you can have built-in benchmarks that are controlled by the go tool to automatically run enough iterations to get a significant result, displayed in number of operations per second.<br /><br /><h3>Integrated Documentation</h3>HTML documentation is built into the language. No need for ugly HTML in your source or weirdly formatted comments. Plaintext comments are turned into very legible documentation, and see above for examples that actually run and can have their output tested as a part of the tests.<br /><br /><h3>DVCS</h3>Support for distributed version control is built into the language. Want to reference code from a project on github? &nbsp;Just use the url of the project as the import path in your code, <i>e.g.</i> import "github.com/jsmith/foo" &nbsp; When you build your code it'll get downloaded and built automatically.<br /><br />Want to get a tool written in go? &nbsp;From the command line type "go get github.com/jsmith/bar" - go will download the source, build it, and install the executable in your path. &nbsp;Now you can run bar.<br /><br />Any git, SVN, mercurial, or bazaar repository will work, but all the major public source code sites are supported out of the box - github, bitbucket, google code, and launchpad.<br /><br /><h3>Other Cool Stuff</h3><div>Debugging with gdb<br />Integrated profiling tools<br />Easy to define custom includes per targeted OS/architecture (simple _windows will only build if targetting windows)<br />Integrated code parsers and lexers.</div><div><br /></div><h4>Do you even care about the actual language anymore? &nbsp;I wouldn't. &nbsp;But just in case:</h4><ul><li>C-like</li><li>Garbage Collected</li><li>Statically typed</li><li>...but with type inference so you're not typing boilerplate all the time: a := "my string"</li><li>Implicit interfaces - if a type has the methods of an interface, it implements the interface</li><li>Pointers but no pointer arithmetic (thank god)</li><li>First class functions</li><li>No exceptions</li><li>...but multiple returns from a single function so you don't have to overload return types</li><li>Everything is UTF8 (both strings and source code.. yes you can have Î˜ as a variable name now)</li><li>Highly performant asynchronous code that is trivial to write</li><li>A deep standard library that does most of the boring stuff for you</li></ul><div><br /></div>
