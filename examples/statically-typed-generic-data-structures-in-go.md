+++
title = "Statically typed generic data structures in Go"
date = 2013-04-17T08:01:00Z
updated = 2014-03-18T15:26:51Z
tags = ["programming", "golang"]
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

<br />I gave a talk at the <a href="https://plus.google.com/u/0/communities/103337146295481792015" target="_blank">Go Boston</a> meetup last night and figured I should write it up and put it here.<br /><div><br /></div><br />The second thing everyone says when they read up on Go is "There are no generics!". <br /><div><br /></div><div>(The first thing people say is "There are no exceptions!")<br /><div><br /></div><div>Both are only mostly true, &nbsp;but we're only going to talk about generics today.</div><div><br /></div><div>Go has generic built-in data structures - arrays, slices, maps, and channels. You just can't create your own new type, and you can't create generic functions. So, what's a programmer to do? Find another language?</div><div><br /></div><div>No. Many, possibly even most, problems can be solved with the built-in data structures. You can write pretty huge applications just using maps and slices and the occasional channel. There may be a tiny bit of code duplication, but probably not much, and certainly not any tricky code.</div><div><br /></div><div>However, there definitely are times when you need more complicated data structures. Most people writing Go solve this problem by using Interface{}, the empty interface, which is basically like Object in C# or Java or void * in C/C++. &nbsp;It's a thing that can hold any type... but then you need to type cast it to get at the actual type. This breaks static typing, since the compiler can't tell if you make a mistake and pass the wrong type into something that takes an Interface{}, and it can't tell until runtime if a cast will succeed or not.</div><div><br /></div><div>So, is there any solution? Yes. The inspiration comes from the standard library's<a href="http://golang.org/pkg/sort/#Interface" target="_blank"> sort package</a>. Package sort can sort a slice of any type, it can even sort things that aren't slices, if you've made your own custom data structure. How does it do that? To sort something, it must support the methods on sort.Interface. Most interesting is Less(i, j int). Less returns true if the item at index i in your data structure is Less than the object at index j in your data structure. Your code has to implement what "Less" means... and by only using indices, sort doesn't need to know the types of objects held in your data structure.&nbsp;</div><div><br /></div><div>This use of indices to blindly access data in a separate data structure is how we'll implement our strongly typed tree. The tree structure will hold an index as its data value in each node, and the indices will index into a data structure that holds the actual objects. To make a tree of a new type, you simply implement a Compare function that the tree can use to compare the values at two indices in your data structure. You can use whatever data structure you like, probably a slice or a map, as long as you can use integers to reference values in the data structure.</div><div><br /></div><div>In this way we separate the organization of the data from the storage of the data. The tree structure holds the organization, a slice or map (or something custom) stores the data. The indices are the generic pointers into the storage that holds the actual strongly typed values.</div><div><br /></div><div>This does require a little code for each new tree type, just as using package sort requires a little code for each type. However, it's only a few lines for a few functions, wrapping a tree and your data.&nbsp;</div><div><br /></div><div>You can check out an example binary search tree I wrote that uses this technique in my github account<br /><br /><a href="https://github.com/natefinch/tree">https://github.com/natefinch/tree</a><br /><br />or go get the runnable sample tree:<br /><br />go get github.com/natefinch/treesample</div><div><br /></div><div>This required only 36 lines of code to make the actual tree structure (including empty lines and comments).</div><div><br /></div><div>In some simple benchmarks, this implementation of a tree is about 25% faster than using the same code with Interface{} as the values and casting at runtime.... plus it's strongly typed.</div></div>
