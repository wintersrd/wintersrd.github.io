+++
title = "Don't Panic: Exceptions Considered Harmful"
date = 2014-07-14T05:43:00Z
updated = 2014-07-14T05:43:53Z
draft = true
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

One of the most common complaints against Go is its lack of exceptions. &nbsp;Go is often said to be stuck in the past, without this modern programming convenience. &nbsp;I think this is actually completely backwards - exceptions are an old fashioned idea that do not fit with modern programming environments, or modern knowledge of what makes programs robust.<br /><br />The main reason for this is multi-threaded applications. &nbsp;Exceptions as a concept only really make sense in a single threaded application. &nbsp;Almost every argument about why they're good falls down once you start running dozens or hundreds of independent threads.... and to be honest, they don't make much sense in single threaded environments either.<br /><br /><b>Invisible Control Flow</b><br /><br /><pre style="tab-size: 4;">def foo():</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; a = bar()</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; b = baz(a)</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; return bat(b)</pre><br /><br />Where are the exit points for this function? &nbsp;You don't know. &nbsp;You <i>can't</i>&nbsp;know. &nbsp;Any of the functions you call may throw an exception. &nbsp;Sure, you can look at the implementations of bar, baz, and bat to see if they throw, but if they call any other functions, you'll have to go look at those implementations, too, etc etc. &nbsp;And god forbid if someone changes one of those functions in 6 months to throw.<br /><br />So, if you don't know where the function can exit, how can you know what it'll do? &nbsp;How can you know if the function is <i>correct</i>? &nbsp;This is one of my main arguments against exceptions... they mean that I don't trust my own code, because I can't tell if it's correct, without a hell of a lot of inspection, even for trivial functions.<br /><br />Compare to the Go version:<br /><br /><pre style="tab-size: 4;">func Foo() int {</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; a := bar()</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; b := baz(a)</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; return bat(b)</pre><br /><pre style="tab-size: 4;">}</pre><br /><br />It's practically identical code. &nbsp;So what's the difference? &nbsp;I <i>know</i>&nbsp;what the exit points of the function are. &nbsp;There's just one - when we return the value returned by bat. &nbsp;I <i>know</i>&nbsp;that bar, baz, and bat can't fail, because they don't return errors, and if they did, the compiler would immediately tell me that my code was wrong. &nbsp;That has an amazing effect on my ability to understand my own code, just by looking at it. &nbsp;In addition, if someone later changes baz so that it may fail, this code will no longer compile.<br /><br /><b>Stack Traces</b><br /><b><br /></b>People complain that Go's errors don't have stack traces, so you can't even tell what was going on when you get an error. &nbsp;This is actually only partially true - an error is an interface, and you are perfectly able to write an error implementation that prints out a stack trace. &nbsp;However, as I said above, modern applications are not single threaded. &nbsp;There's not one stack, there's dozens, possibly hundreds or even thousands.<br /><br />The stack trace of the error you're handling may only be 3 levels deep, because someone just fired off a goroutine to run something asynchronously. &nbsp;Showing those three lines probably doesn't tell you much. &nbsp;You'd need to dump all the stack traces of all the threads in your application to actually get an idea of what was going on, and even then, you can't tell which thread spawned which other thread, which thread is waiting to receive data from another thread, etc. <br /><br />In addition, stack traces are useless to computers... you know, the thing that's actually running your code. &nbsp;No one ever writes a handler for an exception and parses the stack trace to try to find out how to handle the error. &nbsp;Stack traces are nice functionality to have for programmers to debug problems, but they're only really useful with exceptions if something goes completely wrong and no one handles your error, which hopefully doesn't happen often, right? So now you're left with the exception type and value, just like Go's error interface.<br /><br /><b>You Can Ignore Exceptions</b><br /><br />Another common complaint about Go's error handling is that you can ignore an error and continue running in an unknown state, whereas exceptions can't be ignored. &nbsp;Again, this is an argument from another era where we were all running single threaded applications. &nbsp;Uncaught exceptions will <i>not</i> always terminate your program.<br /><br />Maybe in 1997 they (almost) always would. In 2014, we have multi-threaded applications. &nbsp;In Python, Ruby, Java, and C#, if you have an uncaught exception, it terminates the thread where the exception originated. &nbsp;If this is the main thread of the application, the application is terminated. &nbsp;If it is not the main thread, that thread is terminated and the application continues running happily along as if nothing happened <i>and the exception is ignored</i>.<br /><br />Not only that, but you can often ignore errors accidentally, by making a too-broad try/catch that ends up catching exceptions thrown from six levels deep that you didn't even know existed (or perhaps&nbsp;<i>didn't</i>&nbsp;exist when you first wrote the code).<br /><div><br /></div><b>Errors in Go are Easy to Ignore</b><br /><br />Often times, a function call in Go will return both a value and an error. That error must be either referenced or explicitly discarded, or your code won't compile, like so:&nbsp;http://play.golang.org/p/j7XsJlnUWE<br /><br />For functions that only return a single error, you&nbsp;<i>can</i>&nbsp;simply not assign the error to anything, however there are linters such as&nbsp;<a href="https://github.com/kisielk/errcheck" target="_blank">errcheck</a>&nbsp;which can find these spots and inform you when you're doing something dumb. &nbsp;Also, unlike exceptions in most languages, error returns are a normal part of Go function signatures, so it's trivial to look at a function you're calling and determine if it may fail... So, usually this just never comes up. If it a function can return an error, you handle it, if it doesn't, you don't.<br /><br />Contrast this to exceptions in anything except Java (and in many Java programs that have a lot of <pre style="tab-size: 4;">throws Exception</pre> statements) where you have to either trust the function's documentation, or inspect the code of the function (and all functions it calls) to know if it might throw an exception. &nbsp;It's much easier to fail to realize a function may throw an exception. &nbsp;And sure, if it's in the main thread of your application, the application will crash if it happens. &nbsp;However, that's a runtime error that may only happen under bizarre circumstances, and the users of your application will certainly not appreciate that their application crashed. &nbsp;And if it happens in a background thread... well, good luck.<br /><br /><b>The Boilerplate Myth</b><br /><br />One of the most common complaints against Go's error handling is that Go forces you to type this all the time:<br /><br /><pre style="tab-size: 4;">f, err := os.Open("foo")</pre><br /><pre style="tab-size: 4;">if err != nil {</pre><br /><pre style="tab-size: 4;">&nbsp; &nbsp; return nil</pre><br /><pre style="tab-size: 4;">}</pre><br /><br />Whereas in other languages, you can just let the exception fly, like this:<br /><br /><pre style="tab-size: 4;">f = open('foo', 'r')</pre><br /><br /><span style="font-family: inherit;">In toy examples, this is true, however, in more realistic code that actually tries to handle errors correctly, the difference quickly becomes muddied.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">Take, for example, a function that merges files: it opens two files, appends the contents of one to the other.</span><br /><span style="font-family: inherit;"><br /></span>Here's the trivial example most people think about when they think of doing this in a language with exceptions:<br /><br />def Merge(from, into):<br />&nbsp; &nbsp;<br /> <span style="font-family: inherit;"><br /></span><pre style="tab-size: 4;"><br /></pre><pre style="tab-size: 4;"><br /></pre><br /><b>The Happy Path Myth</b><br /><b><br /></b>Another common complaint is that inline error handling muddies your code's "happy path", and that error handling should be done in an "error path". &nbsp;Again, this is a complaint that appears true for toy examples, but falls down in real code. &nbsp;Real code does not have one "happy" path. &nbsp;It just has paths. <br /><br />Any non-trivial code has more than one execution path even if it hits no unexpected errors. &nbsp;What do you even qualify as an error? &nbsp;If the configuration file is missing, is that an error? Or is that just an expected state of the world, where you use the default config values? <br /><br />Yes, maybe that network call will fail sometimes and you'll need to retry. &nbsp;That's not a happy path or an error path, it's just a path that you need to recognize and handle. <br /><b><br /></b><br /><br /><br /><br /><br /><br /><br /><br />
