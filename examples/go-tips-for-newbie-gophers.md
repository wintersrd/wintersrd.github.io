+++
title = "Go Tips for Newbie Gophers"
date = 2014-03-15T09:00:00Z
updated = 2014-03-21T11:02:33Z
tags = ["Go", "programming", "golang"]
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

This is just a collection of tips that would have saved me a lot of time if I had known about them when I was a newbie:<br /><br /><b>Build or test everything under the current directory and subdirectories:</b><br /><b><br /></b><pre style="tab-size: 4;">go build ./...<br />go test ./...</pre><span style="font-family: inherit;">Technically, both commands take a pattern to match the name of one or more packages, and the ... specifier is a wildcard, so you could do .../foo/... to match all packages under GOPATH with foo in their path.&nbsp;</span><br /><br /><b>Have an io.Writer that writes to an in-memory data structure:</b><br /><br /><div><pre style="tab-size: 4;">b := &amp;bytes.Buffer{}<br />thing.WriteTo(b)</pre><b>Have an io.Reader read from a string (useful when you want to use a string as the input data for something):</b><br /><pre style="tab-size: 4;">r := strings.NewReader(myString)<br />thing.ReadFrom\(r)</pre><b>Copy data from a reader to a writer:</b><br /><br /><pre style="tab-size: 4;">io.Copy(toWriter, fromReader)</pre><b>Timeout waiting on a channel:</b><br /><br /><pre style="tab-size: 4;">select {<br/>&nbsp; &nbsp;case val := &lt;- ch<br/>&nbsp; &nbsp; &nbsp; &nbsp;// use val<br/>&nbsp; &nbsp;case &lt;-time.After(time.Second*5)<br />}</pre><b>Convert a slice of bytes to a string:</b><pre style="tab-size: 4;">var b []byte = getData()<br/>s := string(b)</pre><b>Passing a nil pointer into an interface does not result in a nil interface:</b><pre style="tab-size: 4;">func isNil(i interface{}) bool {<br/>&nbsp; &nbsp; return i == nil<br/>}<br/>var f *foo = nil<br />fmt.Println(isNil(f)) &nbsp;// prints false</pre></div><div><b>The only way to get a nil interface is to pass the keyword nil:</b></div><div><pre style="tab-size: 4;">var f *foo = nil<br/>if f == nil {<br />&nbsp; &nbsp; fmt.Println(isNil(nil)) &nbsp;// prints true<br/>}</pre></div><div><b>How to remember where the arrow goes for channels:</b></div><div><br /></div><div>The arrow points in the direction of data flow, either into or out of the channel, and always points left.</div><div><br /></div><div><b>The above is generalizable to anything where you have a source and destination, or reading and writing, or assigning.</b></div><div><b><br /></b></div><div>Data is taken from the right and assigned to the left, just as it is with a := b. &nbsp;So, like io.Copy, you know that the reader (source) is on the right, the writer (destination) is on the left: &nbsp;io.Copy(dest, src).</div><div><br /></div><div><b>If you ever think "man, someone should have made a helper function to do this!", chances are they have, and it's in the std lib somewhere.</b></div></div>
